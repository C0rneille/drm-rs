/* automatically generated by rust-bindgen */

pub const __BITS_PER_LONG: libc::c_uint = 64;
pub const __FD_SETSIZE: libc::c_uint = 1024;
pub const _IOC_NRBITS: libc::c_uint = 8;
pub const _IOC_TYPEBITS: libc::c_uint = 8;
pub const _IOC_SIZEBITS: libc::c_uint = 14;
pub const _IOC_DIRBITS: libc::c_uint = 2;
pub const _IOC_NRMASK: libc::c_uint = 255;
pub const _IOC_TYPEMASK: libc::c_uint = 255;
pub const _IOC_SIZEMASK: libc::c_uint = 16383;
pub const _IOC_DIRMASK: libc::c_uint = 3;
pub const _IOC_NRSHIFT: libc::c_uint = 0;
pub const _IOC_TYPESHIFT: libc::c_uint = 8;
pub const _IOC_SIZESHIFT: libc::c_uint = 16;
pub const _IOC_DIRSHIFT: libc::c_uint = 30;
pub const _IOC_NONE: libc::c_uint = 0;
pub const _IOC_WRITE: libc::c_uint = 1;
pub const _IOC_READ: libc::c_uint = 2;
pub const IOC_IN: libc::c_uint = 1073741824;
pub const IOC_OUT: libc::c_uint = 2147483648;
pub const IOC_INOUT: libc::c_uint = 3221225472;
pub const IOCSIZE_MASK: libc::c_uint = 1073676288;
pub const IOCSIZE_SHIFT: libc::c_uint = 16;
pub const DRM_NAME: &'static [u8; 4usize] = b"drm\0";
pub const DRM_MIN_ORDER: libc::c_uint = 5;
pub const DRM_MAX_ORDER: libc::c_uint = 22;
pub const DRM_RAM_PERCENT: libc::c_uint = 10;
pub const _DRM_LOCK_HELD: libc::c_uint = 2147483648;
pub const _DRM_LOCK_CONT: libc::c_uint = 1073741824;
pub const _DRM_VBLANK_HIGH_CRTC_SHIFT: libc::c_uint = 1;
pub const _DRM_PRE_MODESET: libc::c_uint = 1;
pub const _DRM_POST_MODESET: libc::c_uint = 2;
pub const DRM_CAP_DUMB_BUFFER: libc::c_uint = 1;
pub const DRM_CAP_VBLANK_HIGH_CRTC: libc::c_uint = 2;
pub const DRM_CAP_DUMB_PREFERRED_DEPTH: libc::c_uint = 3;
pub const DRM_CAP_DUMB_PREFER_SHADOW: libc::c_uint = 4;
pub const DRM_CAP_PRIME: libc::c_uint = 5;
pub const DRM_PRIME_CAP_IMPORT: libc::c_uint = 1;
pub const DRM_PRIME_CAP_EXPORT: libc::c_uint = 2;
pub const DRM_CAP_TIMESTAMP_MONOTONIC: libc::c_uint = 6;
pub const DRM_CAP_ASYNC_PAGE_FLIP: libc::c_uint = 7;
pub const DRM_CAP_CURSOR_WIDTH: libc::c_uint = 8;
pub const DRM_CAP_CURSOR_HEIGHT: libc::c_uint = 9;
pub const DRM_CAP_ADDFB2_MODIFIERS: libc::c_uint = 16;
pub const DRM_CAP_PAGE_FLIP_TARGET: libc::c_uint = 17;
pub const DRM_CAP_CRTC_IN_VBLANK_EVENT: libc::c_uint = 18;
pub const DRM_CAP_SYNCOBJ: libc::c_uint = 19;
pub const DRM_CLIENT_CAP_STEREO_3D: libc::c_uint = 1;
pub const DRM_CLIENT_CAP_UNIVERSAL_PLANES: libc::c_uint = 2;
pub const DRM_CLIENT_CAP_ATOMIC: libc::c_uint = 3;
pub const DRM_SYNCOBJ_CREATE_SIGNALED: libc::c_uint = 1;
pub const DRM_SYNCOBJ_FD_TO_HANDLE_FLAGS_IMPORT_SYNC_FILE: libc::c_uint = 1;
pub const DRM_SYNCOBJ_HANDLE_TO_FD_FLAGS_EXPORT_SYNC_FILE: libc::c_uint = 1;
pub const DRM_SYNCOBJ_WAIT_FLAGS_WAIT_ALL: libc::c_uint = 1;
pub const DRM_SYNCOBJ_WAIT_FLAGS_WAIT_FOR_SUBMIT: libc::c_uint = 2;
pub const DRM_CRTC_SEQUENCE_RELATIVE: libc::c_uint = 1;
pub const DRM_CRTC_SEQUENCE_NEXT_ON_MISS: libc::c_uint = 2;
pub const DRM_DISPLAY_INFO_LEN: libc::c_uint = 32;
pub const DRM_CONNECTOR_NAME_LEN: libc::c_uint = 32;
pub const DRM_DISPLAY_MODE_LEN: libc::c_uint = 32;
pub const DRM_PROP_NAME_LEN: libc::c_uint = 32;
pub const DRM_MODE_TYPE_BUILTIN: libc::c_uint = 1;
pub const DRM_MODE_TYPE_CLOCK_C: libc::c_uint = 3;
pub const DRM_MODE_TYPE_CRTC_C: libc::c_uint = 5;
pub const DRM_MODE_TYPE_PREFERRED: libc::c_uint = 8;
pub const DRM_MODE_TYPE_DEFAULT: libc::c_uint = 16;
pub const DRM_MODE_TYPE_USERDEF: libc::c_uint = 32;
pub const DRM_MODE_TYPE_DRIVER: libc::c_uint = 64;
pub const DRM_MODE_FLAG_PHSYNC: libc::c_uint = 1;
pub const DRM_MODE_FLAG_NHSYNC: libc::c_uint = 2;
pub const DRM_MODE_FLAG_PVSYNC: libc::c_uint = 4;
pub const DRM_MODE_FLAG_NVSYNC: libc::c_uint = 8;
pub const DRM_MODE_FLAG_INTERLACE: libc::c_uint = 16;
pub const DRM_MODE_FLAG_DBLSCAN: libc::c_uint = 32;
pub const DRM_MODE_FLAG_CSYNC: libc::c_uint = 64;
pub const DRM_MODE_FLAG_PCSYNC: libc::c_uint = 128;
pub const DRM_MODE_FLAG_NCSYNC: libc::c_uint = 256;
pub const DRM_MODE_FLAG_HSKEW: libc::c_uint = 512;
pub const DRM_MODE_FLAG_BCAST: libc::c_uint = 1024;
pub const DRM_MODE_FLAG_PIXMUX: libc::c_uint = 2048;
pub const DRM_MODE_FLAG_DBLCLK: libc::c_uint = 4096;
pub const DRM_MODE_FLAG_CLKDIV2: libc::c_uint = 8192;
pub const DRM_MODE_FLAG_3D_MASK: libc::c_uint = 507904;
pub const DRM_MODE_FLAG_3D_NONE: libc::c_uint = 0;
pub const DRM_MODE_FLAG_3D_FRAME_PACKING: libc::c_uint = 16384;
pub const DRM_MODE_FLAG_3D_FIELD_ALTERNATIVE: libc::c_uint = 32768;
pub const DRM_MODE_FLAG_3D_LINE_ALTERNATIVE: libc::c_uint = 49152;
pub const DRM_MODE_FLAG_3D_SIDE_BY_SIDE_FULL: libc::c_uint = 65536;
pub const DRM_MODE_FLAG_3D_L_DEPTH: libc::c_uint = 81920;
pub const DRM_MODE_FLAG_3D_L_DEPTH_GFX_GFX_DEPTH: libc::c_uint = 98304;
pub const DRM_MODE_FLAG_3D_TOP_AND_BOTTOM: libc::c_uint = 114688;
pub const DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF: libc::c_uint = 131072;
pub const DRM_MODE_PICTURE_ASPECT_NONE: libc::c_uint = 0;
pub const DRM_MODE_PICTURE_ASPECT_4_3: libc::c_uint = 1;
pub const DRM_MODE_PICTURE_ASPECT_16_9: libc::c_uint = 2;
pub const DRM_MODE_FLAG_PIC_AR_MASK: libc::c_uint = 7864320;
pub const DRM_MODE_FLAG_PIC_AR_NONE: libc::c_uint = 0;
pub const DRM_MODE_FLAG_PIC_AR_4_3: libc::c_uint = 524288;
pub const DRM_MODE_FLAG_PIC_AR_16_9: libc::c_uint = 1048576;
pub const DRM_MODE_DPMS_ON: libc::c_uint = 0;
pub const DRM_MODE_DPMS_STANDBY: libc::c_uint = 1;
pub const DRM_MODE_DPMS_SUSPEND: libc::c_uint = 2;
pub const DRM_MODE_DPMS_OFF: libc::c_uint = 3;
pub const DRM_MODE_SCALE_NONE: libc::c_uint = 0;
pub const DRM_MODE_SCALE_FULLSCREEN: libc::c_uint = 1;
pub const DRM_MODE_SCALE_CENTER: libc::c_uint = 2;
pub const DRM_MODE_SCALE_ASPECT: libc::c_uint = 3;
pub const DRM_MODE_DITHERING_OFF: libc::c_uint = 0;
pub const DRM_MODE_DITHERING_ON: libc::c_uint = 1;
pub const DRM_MODE_DITHERING_AUTO: libc::c_uint = 2;
pub const DRM_MODE_DIRTY_OFF: libc::c_uint = 0;
pub const DRM_MODE_DIRTY_ON: libc::c_uint = 1;
pub const DRM_MODE_DIRTY_ANNOTATE: libc::c_uint = 2;
pub const DRM_MODE_LINK_STATUS_GOOD: libc::c_uint = 0;
pub const DRM_MODE_LINK_STATUS_BAD: libc::c_uint = 1;
pub const DRM_MODE_ROTATE_0: libc::c_uint = 1;
pub const DRM_MODE_ROTATE_90: libc::c_uint = 2;
pub const DRM_MODE_ROTATE_180: libc::c_uint = 4;
pub const DRM_MODE_ROTATE_270: libc::c_uint = 8;
pub const DRM_MODE_ROTATE_MASK: libc::c_uint = 15;
pub const DRM_MODE_REFLECT_X: libc::c_uint = 16;
pub const DRM_MODE_REFLECT_Y: libc::c_uint = 32;
pub const DRM_MODE_REFLECT_MASK: libc::c_uint = 48;
pub const DRM_MODE_PRESENT_TOP_FIELD: libc::c_uint = 1;
pub const DRM_MODE_PRESENT_BOTTOM_FIELD: libc::c_uint = 2;
pub const DRM_MODE_ENCODER_NONE: libc::c_uint = 0;
pub const DRM_MODE_ENCODER_DAC: libc::c_uint = 1;
pub const DRM_MODE_ENCODER_TMDS: libc::c_uint = 2;
pub const DRM_MODE_ENCODER_LVDS: libc::c_uint = 3;
pub const DRM_MODE_ENCODER_TVDAC: libc::c_uint = 4;
pub const DRM_MODE_ENCODER_VIRTUAL: libc::c_uint = 5;
pub const DRM_MODE_ENCODER_DSI: libc::c_uint = 6;
pub const DRM_MODE_ENCODER_DPMST: libc::c_uint = 7;
pub const DRM_MODE_ENCODER_DPI: libc::c_uint = 8;
pub const DRM_MODE_CONNECTOR_Unknown: libc::c_uint = 0;
pub const DRM_MODE_CONNECTOR_VGA: libc::c_uint = 1;
pub const DRM_MODE_CONNECTOR_DVII: libc::c_uint = 2;
pub const DRM_MODE_CONNECTOR_DVID: libc::c_uint = 3;
pub const DRM_MODE_CONNECTOR_DVIA: libc::c_uint = 4;
pub const DRM_MODE_CONNECTOR_Composite: libc::c_uint = 5;
pub const DRM_MODE_CONNECTOR_SVIDEO: libc::c_uint = 6;
pub const DRM_MODE_CONNECTOR_LVDS: libc::c_uint = 7;
pub const DRM_MODE_CONNECTOR_Component: libc::c_uint = 8;
pub const DRM_MODE_CONNECTOR_9PinDIN: libc::c_uint = 9;
pub const DRM_MODE_CONNECTOR_DisplayPort: libc::c_uint = 10;
pub const DRM_MODE_CONNECTOR_HDMIA: libc::c_uint = 11;
pub const DRM_MODE_CONNECTOR_HDMIB: libc::c_uint = 12;
pub const DRM_MODE_CONNECTOR_TV: libc::c_uint = 13;
pub const DRM_MODE_CONNECTOR_eDP: libc::c_uint = 14;
pub const DRM_MODE_CONNECTOR_VIRTUAL: libc::c_uint = 15;
pub const DRM_MODE_CONNECTOR_DSI: libc::c_uint = 16;
pub const DRM_MODE_CONNECTOR_DPI: libc::c_uint = 17;
pub const DRM_MODE_PROP_PENDING: libc::c_uint = 1;
pub const DRM_MODE_PROP_RANGE: libc::c_uint = 2;
pub const DRM_MODE_PROP_IMMUTABLE: libc::c_uint = 4;
pub const DRM_MODE_PROP_ENUM: libc::c_uint = 8;
pub const DRM_MODE_PROP_BLOB: libc::c_uint = 16;
pub const DRM_MODE_PROP_BITMASK: libc::c_uint = 32;
pub const DRM_MODE_PROP_LEGACY_TYPE: libc::c_uint = 58;
pub const DRM_MODE_PROP_EXTENDED_TYPE: libc::c_uint = 65472;
pub const DRM_MODE_PROP_ATOMIC: libc::c_uint = 2147483648;
pub const DRM_MODE_OBJECT_CRTC: libc::c_uint = 3435973836;
pub const DRM_MODE_OBJECT_CONNECTOR: libc::c_uint = 3233857728;
pub const DRM_MODE_OBJECT_ENCODER: libc::c_uint = 3772834016;
pub const DRM_MODE_OBJECT_MODE: libc::c_uint = 3739147998;
pub const DRM_MODE_OBJECT_PROPERTY: libc::c_uint = 2964369584;
pub const DRM_MODE_OBJECT_FB: libc::c_uint = 4227595259;
pub const DRM_MODE_OBJECT_BLOB: libc::c_uint = 3149642683;
pub const DRM_MODE_OBJECT_PLANE: libc::c_uint = 4008636142;
pub const DRM_MODE_OBJECT_ANY: libc::c_uint = 0;
pub const DRM_MODE_FB_INTERLACED: libc::c_uint = 1;
pub const DRM_MODE_FB_MODIFIERS: libc::c_uint = 2;
pub const DRM_MODE_FB_DIRTY_ANNOTATE_COPY: libc::c_uint = 1;
pub const DRM_MODE_FB_DIRTY_ANNOTATE_FILL: libc::c_uint = 2;
pub const DRM_MODE_FB_DIRTY_FLAGS: libc::c_uint = 3;
pub const DRM_MODE_FB_DIRTY_MAX_CLIPS: libc::c_uint = 256;
pub const DRM_MODE_CURSOR_BO: libc::c_uint = 1;
pub const DRM_MODE_CURSOR_MOVE: libc::c_uint = 2;
pub const DRM_MODE_CURSOR_FLAGS: libc::c_uint = 3;
pub const DRM_MODE_PAGE_FLIP_EVENT: libc::c_uint = 1;
pub const DRM_MODE_PAGE_FLIP_ASYNC: libc::c_uint = 2;
pub const DRM_MODE_PAGE_FLIP_TARGET_ABSOLUTE: libc::c_uint = 4;
pub const DRM_MODE_PAGE_FLIP_TARGET_RELATIVE: libc::c_uint = 8;
pub const DRM_MODE_PAGE_FLIP_TARGET: libc::c_uint = 12;
pub const DRM_MODE_PAGE_FLIP_FLAGS: libc::c_uint = 15;
pub const DRM_MODE_ATOMIC_TEST_ONLY: libc::c_uint = 256;
pub const DRM_MODE_ATOMIC_NONBLOCK: libc::c_uint = 512;
pub const DRM_MODE_ATOMIC_ALLOW_MODESET: libc::c_uint = 1024;
pub const DRM_MODE_ATOMIC_FLAGS: libc::c_uint = 1795;
pub const FORMAT_BLOB_CURRENT: libc::c_uint = 1;
pub const DRM_IOCTL_BASE: u8 = 100u8;
pub const DRM_COMMAND_BASE: libc::c_uint = 64;
pub const DRM_COMMAND_END: libc::c_uint = 160;
pub const DRM_EVENT_VBLANK: libc::c_uint = 1;
pub const DRM_EVENT_FLIP_COMPLETE: libc::c_uint = 2;
pub const DRM_EVENT_CRTC_SEQUENCE: libc::c_uint = 3;
pub type __s8 = libc::c_schar;
pub type __u8 = libc::c_uchar;
pub type __s16 = libc::c_short;
pub type __u16 = libc::c_ushort;
pub type __s32 = libc::c_int;
pub type __u32 = libc::c_uint;
pub type __s64 = libc::c_longlong;
pub type __u64 = libc::c_ulonglong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __kernel_fd_set {
    pub fds_bits: [libc::c_ulong; 16usize],
}
pub type __kernel_sighandler_t = ::std::option::Option<unsafe extern "C" fn(arg1: libc::c_int)>;
pub type __kernel_key_t = libc::c_int;
pub type __kernel_mqd_t = libc::c_int;
pub type __kernel_old_uid_t = libc::c_ushort;
pub type __kernel_old_gid_t = libc::c_ushort;
pub type __kernel_old_dev_t = libc::c_ulong;
pub type __kernel_long_t = libc::c_long;
pub type __kernel_ulong_t = libc::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = libc::c_uint;
pub type __kernel_pid_t = libc::c_int;
pub type __kernel_ipc_pid_t = libc::c_int;
pub type __kernel_uid_t = libc::c_uint;
pub type __kernel_gid_t = libc::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = libc::c_int;
pub type __kernel_uid32_t = libc::c_uint;
pub type __kernel_gid32_t = libc::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __kernel_fsid_t {
    pub val: [libc::c_int; 2usize],
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = libc::c_longlong;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = libc::c_int;
pub type __kernel_clockid_t = libc::c_int;
pub type __kernel_caddr_t = *mut libc::c_char;
pub type __kernel_uid16_t = libc::c_ushort;
pub type __kernel_gid16_t = libc::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type drm_handle_t = libc::c_uint;
pub type drm_context_t = libc::c_uint;
pub type drm_drawable_t = libc::c_uint;
pub type drm_magic_t = libc::c_uint;
/// Cliprect.
///
/// \warning: If you change this structure, make sure you change
/// XF86DRIClipRectRec in the server as well
///
/// \note KW: Actually it's illegal to change either for
/// backwards-compatibility reasons.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_clip_rect {
    pub x1: libc::c_ushort,
    pub y1: libc::c_ushort,
    pub x2: libc::c_ushort,
    pub y2: libc::c_ushort,
}
/// Drawable information.
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_drawable_info {
    pub num_rects: libc::c_uint,
    pub rects: *mut drm_clip_rect,
}
impl Default for drm_drawable_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// Texture region,
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_tex_region {
    pub next: libc::c_uchar,
    pub prev: libc::c_uchar,
    pub in_use: libc::c_uchar,
    pub padding: libc::c_uchar,
    pub age: libc::c_uint,
}
/// Hardware lock.
///
/// The lock structure is a simple cache-line aligned integer.  To avoid
/// processor bus contention on a multiprocessor system, there should not be any
/// other data stored in the same cache line.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_hw_lock {
    /// < lock variable
    pub lock: libc::c_uint,
    /// < Pad to cache line
    pub padding: [libc::c_char; 60usize],
}
impl Default for drm_hw_lock {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// DRM_IOCTL_VERSION ioctl argument type.
///
/// \sa drmGetVersion().
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_version {
    /// < Major version
    pub version_major: libc::c_int,
    /// < Minor version
    pub version_minor: libc::c_int,
    /// < Patch level
    pub version_patchlevel: libc::c_int,
    /// < Length of name buffer
    pub name_len: __kernel_size_t,
    /// < Name of driver
    pub name: *mut libc::c_char,
    /// < Length of date buffer
    pub date_len: __kernel_size_t,
    /// < User-space buffer to hold date
    pub date: *mut libc::c_char,
    /// < Length of desc buffer
    pub desc_len: __kernel_size_t,
    /// < User-space buffer to hold desc
    pub desc: *mut libc::c_char,
}
impl Default for drm_version {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// DRM_IOCTL_GET_UNIQUE ioctl argument type.
///
/// \sa drmGetBusid() and drmSetBusId().
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_unique {
    /// < Length of unique
    pub unique_len: __kernel_size_t,
    /// < Unique name for driver instantiation
    pub unique: *mut libc::c_char,
}
impl Default for drm_unique {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_list {
    /// < Length of user-space structures
    pub count: libc::c_int,
    pub version: *mut drm_version,
}
impl Default for drm_list {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_block {
    pub unused: libc::c_int,
}
/// DRM_IOCTL_CONTROL ioctl argument type.
///
/// \sa drmCtlInstHandler() and drmCtlUninstHandler().
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_control {
    pub func: drm_control__bindgen_ty_1::Type,
    pub irq: libc::c_int,
}
pub mod drm_control__bindgen_ty_1 {
    pub type Type = u32;
    pub const DRM_ADD_COMMAND: Type = 0;
    pub const DRM_RM_COMMAND: Type = 1;
    pub const DRM_INST_HANDLER: Type = 2;
    pub const DRM_UNINST_HANDLER: Type = 3;
}
impl Default for drm_control {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod drm_map_type {
    pub type Type = u32;
    pub const _DRM_FRAME_BUFFER: Type = 0;
    pub const _DRM_REGISTERS: Type = 1;
    pub const _DRM_SHM: Type = 2;
    pub const _DRM_AGP: Type = 3;
    pub const _DRM_SCATTER_GATHER: Type = 4;
    pub const _DRM_CONSISTENT: Type = 5;
}
pub const _DRM_RESTRICTED: drm_map_flags = drm_map_flags(1);
pub const _DRM_READ_ONLY: drm_map_flags = drm_map_flags(2);
pub const _DRM_LOCKED: drm_map_flags = drm_map_flags(4);
pub const _DRM_KERNEL: drm_map_flags = drm_map_flags(8);
pub const _DRM_WRITE_COMBINING: drm_map_flags = drm_map_flags(16);
pub const _DRM_CONTAINS_LOCK: drm_map_flags = drm_map_flags(32);
pub const _DRM_REMOVABLE: drm_map_flags = drm_map_flags(64);
pub const _DRM_DRIVER: drm_map_flags = drm_map_flags(128);
impl ::std::ops::BitOr<drm_map_flags> for drm_map_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        drm_map_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for drm_map_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: drm_map_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<drm_map_flags> for drm_map_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        drm_map_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for drm_map_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: drm_map_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(C)]
/// Memory mapping flags.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct drm_map_flags(pub u32);
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_ctx_priv_map {
    /// < Context requesting private mapping
    pub ctx_id: libc::c_uint,
    /// < Handle of map
    pub handle: *mut libc::c_void,
}
impl Default for drm_ctx_priv_map {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// DRM_IOCTL_GET_MAP, DRM_IOCTL_ADD_MAP and DRM_IOCTL_RM_MAP ioctls
/// argument type.
///
/// \sa drmAddMap().
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_map {
    /// < Requested physical address (0 for SAREA)
    pub offset: libc::c_ulong,
    /// < Requested physical size (bytes)
    pub size: libc::c_ulong,
    /// < Type of memory to map
    pub type_: drm_map_type::Type,
    /// < Flags
    pub flags: drm_map_flags,
    /// < User-space: "Handle" to pass to mmap() */
    /// /**< Kernel-space: kernel-virtual address
    pub handle: *mut libc::c_void,
    /// < MTRR slot used
    pub mtrr: libc::c_int,
}
impl Default for drm_map {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// DRM_IOCTL_GET_CLIENT ioctl argument type.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_client {
    /// < Which client desired?
    pub idx: libc::c_int,
    /// < Is client authenticated?
    pub auth: libc::c_int,
    /// < Process ID
    pub pid: libc::c_ulong,
    /// < User ID
    pub uid: libc::c_ulong,
    /// < Magic
    pub magic: libc::c_ulong,
    /// < Ioctl count
    pub iocs: libc::c_ulong,
}
pub mod drm_stat_type {
    pub type Type = u32;
    pub const _DRM_STAT_LOCK: Type = 0;
    pub const _DRM_STAT_OPENS: Type = 1;
    pub const _DRM_STAT_CLOSES: Type = 2;
    pub const _DRM_STAT_IOCTLS: Type = 3;
    pub const _DRM_STAT_LOCKS: Type = 4;
    pub const _DRM_STAT_UNLOCKS: Type = 5;
    pub const _DRM_STAT_VALUE: Type = 6;
    pub const _DRM_STAT_BYTE: Type = 7;
    pub const _DRM_STAT_COUNT: Type = 8;
    pub const _DRM_STAT_IRQ: Type = 9;
    pub const _DRM_STAT_PRIMARY: Type = 10;
    pub const _DRM_STAT_SECONDARY: Type = 11;
    pub const _DRM_STAT_DMA: Type = 12;
    pub const _DRM_STAT_SPECIAL: Type = 13;
    pub const _DRM_STAT_MISSED: Type = 14;
}
/// DRM_IOCTL_GET_STATS ioctl argument type.
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_stats {
    pub count: libc::c_ulong,
    pub data: [drm_stats__bindgen_ty_1; 15usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_stats__bindgen_ty_1 {
    pub value: libc::c_ulong,
    pub type_: drm_stat_type::Type,
}
impl Default for drm_stats__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl Default for drm_stats {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const _DRM_LOCK_READY: drm_lock_flags = drm_lock_flags(1);
pub const _DRM_LOCK_QUIESCENT: drm_lock_flags = drm_lock_flags(2);
pub const _DRM_LOCK_FLUSH: drm_lock_flags = drm_lock_flags(4);
pub const _DRM_LOCK_FLUSH_ALL: drm_lock_flags = drm_lock_flags(8);
pub const _DRM_HALT_ALL_QUEUES: drm_lock_flags = drm_lock_flags(16);
pub const _DRM_HALT_CUR_QUEUES: drm_lock_flags = drm_lock_flags(32);
impl ::std::ops::BitOr<drm_lock_flags> for drm_lock_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        drm_lock_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for drm_lock_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: drm_lock_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<drm_lock_flags> for drm_lock_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        drm_lock_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for drm_lock_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: drm_lock_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(C)]
/// Hardware locking flags.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct drm_lock_flags(pub u32);
/// DRM_IOCTL_LOCK, DRM_IOCTL_UNLOCK and DRM_IOCTL_FINISH ioctl argument type.
///
/// \sa drmGetLock() and drmUnlock().
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_lock {
    pub context: libc::c_int,
    pub flags: drm_lock_flags,
}
impl Default for drm_lock {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const _DRM_DMA_BLOCK: drm_dma_flags = drm_dma_flags(1);
pub const _DRM_DMA_WHILE_LOCKED: drm_dma_flags = drm_dma_flags(2);
pub const _DRM_DMA_PRIORITY: drm_dma_flags = drm_dma_flags(4);
pub const _DRM_DMA_WAIT: drm_dma_flags = drm_dma_flags(16);
pub const _DRM_DMA_SMALLER_OK: drm_dma_flags = drm_dma_flags(32);
pub const _DRM_DMA_LARGER_OK: drm_dma_flags = drm_dma_flags(64);
impl ::std::ops::BitOr<drm_dma_flags> for drm_dma_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        drm_dma_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for drm_dma_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: drm_dma_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<drm_dma_flags> for drm_dma_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        drm_dma_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for drm_dma_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: drm_dma_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(C)]
/// DMA flags
///
/// \warning
/// These values \e must match xf86drm.h.
///
/// \sa drm_dma.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct drm_dma_flags(pub u32);
/// DRM_IOCTL_ADD_BUFS and DRM_IOCTL_MARK_BUFS ioctl argument type.
///
/// \sa drmAddBufs().
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_buf_desc {
    /// < Number of buffers of this size
    pub count: libc::c_int,
    /// < Size in bytes
    pub size: libc::c_int,
    /// < Low water mark
    pub low_mark: libc::c_int,
    /// < High water mark
    pub high_mark: libc::c_int,
    pub flags: drm_buf_desc__bindgen_ty_1,
    /// <
    /// Start address of where the AGP buffers are
    /// in the AGP aperture
    pub agp_start: libc::c_ulong,
}
pub const _DRM_PAGE_ALIGN: drm_buf_desc__bindgen_ty_1 = 1;
pub const _DRM_AGP_BUFFER: drm_buf_desc__bindgen_ty_1 = 2;
pub const _DRM_SG_BUFFER: drm_buf_desc__bindgen_ty_1 = 4;
pub const _DRM_FB_BUFFER: drm_buf_desc__bindgen_ty_1 = 8;
pub const _DRM_PCI_BUFFER_RO: drm_buf_desc__bindgen_ty_1 = 16;
pub type drm_buf_desc__bindgen_ty_1 = u32;
impl Default for drm_buf_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// DRM_IOCTL_INFO_BUFS ioctl argument type.
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_buf_info {
    /// < Entries in list
    pub count: libc::c_int,
    pub list: *mut drm_buf_desc,
}
impl Default for drm_buf_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// DRM_IOCTL_FREE_BUFS ioctl argument type.
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_buf_free {
    pub count: libc::c_int,
    pub list: *mut libc::c_int,
}
impl Default for drm_buf_free {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// Buffer information
///
/// \sa drm_buf_map.
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_buf_pub {
    /// < Index into the master buffer list
    pub idx: libc::c_int,
    /// < Buffer size
    pub total: libc::c_int,
    /// < Amount of buffer in use (for DMA)
    pub used: libc::c_int,
    /// < Address of buffer
    pub address: *mut libc::c_void,
}
impl Default for drm_buf_pub {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// DRM_IOCTL_MAP_BUFS ioctl argument type.
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_buf_map {
    /// < Length of the buffer list
    pub count: libc::c_int,
    /// < Mmap'd area in user-virtual
    pub virtual_: *mut libc::c_void,
    /// < Buffer information
    pub list: *mut drm_buf_pub,
}
impl Default for drm_buf_map {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// DRM_IOCTL_DMA ioctl argument type.
///
/// Indices here refer to the offset into the buffer list in drm_buf_get.
///
/// \sa drmDMA().
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_dma {
    /// < Context handle
    pub context: libc::c_int,
    /// < Number of buffers to send
    pub send_count: libc::c_int,
    /// < List of handles to buffers
    pub send_indices: *mut libc::c_int,
    /// < Lengths of data to send
    pub send_sizes: *mut libc::c_int,
    /// < Flags
    pub flags: drm_dma_flags,
    /// < Number of buffers requested
    pub request_count: libc::c_int,
    /// < Desired size for buffers
    pub request_size: libc::c_int,
    /// < Buffer information
    pub request_indices: *mut libc::c_int,
    pub request_sizes: *mut libc::c_int,
    /// < Number of buffers granted
    pub granted_count: libc::c_int,
}
impl Default for drm_dma {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const _DRM_CONTEXT_PRESERVED: drm_ctx_flags = drm_ctx_flags(1);
pub const _DRM_CONTEXT_2DONLY: drm_ctx_flags = drm_ctx_flags(2);
impl ::std::ops::BitOr<drm_ctx_flags> for drm_ctx_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        drm_ctx_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for drm_ctx_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: drm_ctx_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<drm_ctx_flags> for drm_ctx_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        drm_ctx_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for drm_ctx_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: drm_ctx_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct drm_ctx_flags(pub u32);
/// DRM_IOCTL_ADD_CTX ioctl argument type.
///
/// \sa drmCreateContext() and drmDestroyContext().
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_ctx {
    pub handle: drm_context_t,
    pub flags: drm_ctx_flags,
}
impl Default for drm_ctx {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// DRM_IOCTL_RES_CTX ioctl argument type.
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_ctx_res {
    pub count: libc::c_int,
    pub contexts: *mut drm_ctx,
}
impl Default for drm_ctx_res {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// DRM_IOCTL_ADD_DRAW and DRM_IOCTL_RM_DRAW ioctl argument type.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_draw {
    pub handle: drm_drawable_t,
}
pub const DRM_DRAWABLE_CLIPRECTS: drm_drawable_info_type_t = 0;
pub type drm_drawable_info_type_t = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_update_draw {
    pub handle: drm_drawable_t,
    pub type_: libc::c_uint,
    pub num: libc::c_uint,
    pub data: libc::c_ulonglong,
}
/// DRM_IOCTL_GET_MAGIC and DRM_IOCTL_AUTH_MAGIC ioctl argument type.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_auth {
    pub magic: drm_magic_t,
}
/// DRM_IOCTL_IRQ_BUSID ioctl argument type.
///
/// \sa drmGetInterruptFromBusID().
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_irq_busid {
    /// < IRQ number
    pub irq: libc::c_int,
    /// < bus number
    pub busnum: libc::c_int,
    /// < device number
    pub devnum: libc::c_int,
    /// < function number
    pub funcnum: libc::c_int,
}
pub const _DRM_VBLANK_ABSOLUTE: drm_vblank_seq_type = 0;
pub const _DRM_VBLANK_RELATIVE: drm_vblank_seq_type = 1;
pub const _DRM_VBLANK_HIGH_CRTC_MASK: drm_vblank_seq_type = 62;
pub const _DRM_VBLANK_EVENT: drm_vblank_seq_type = 67108864;
pub const _DRM_VBLANK_FLIP: drm_vblank_seq_type = 134217728;
pub const _DRM_VBLANK_NEXTONMISS: drm_vblank_seq_type = 268435456;
pub const _DRM_VBLANK_SECONDARY: drm_vblank_seq_type = 536870912;
pub const _DRM_VBLANK_SIGNAL: drm_vblank_seq_type = 1073741824;
pub type drm_vblank_seq_type = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_wait_vblank_request {
    pub type_: drm_vblank_seq_type,
    pub sequence: libc::c_uint,
    pub signal: libc::c_ulong,
}
impl Default for drm_wait_vblank_request {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_wait_vblank_reply {
    pub type_: drm_vblank_seq_type,
    pub sequence: libc::c_uint,
    pub tval_sec: libc::c_long,
    pub tval_usec: libc::c_long,
}
impl Default for drm_wait_vblank_reply {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// DRM_IOCTL_WAIT_VBLANK ioctl argument type.
///
/// \sa drmWaitVBlank().
#[repr(C)]
#[derive(Copy, Clone)]
pub union drm_wait_vblank {
    pub request: drm_wait_vblank_request,
    pub reply: drm_wait_vblank_reply,
    _bindgen_union_align: [u64; 3usize],
}
impl Default for drm_wait_vblank {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// DRM_IOCTL_MODESET_CTL ioctl argument type
///
/// \sa drmModesetCtl().
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_modeset_ctl {
    pub crtc: __u32,
    pub cmd: __u32,
}
/// DRM_IOCTL_AGP_ENABLE ioctl argument type.
///
/// \sa drmAgpEnable().
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_agp_mode {
    /// < AGP mode
    pub mode: libc::c_ulong,
}
/// DRM_IOCTL_AGP_ALLOC and DRM_IOCTL_AGP_FREE ioctls argument type.
///
/// \sa drmAgpAlloc() and drmAgpFree().
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_agp_buffer {
    /// < In bytes -- will round to page boundary
    pub size: libc::c_ulong,
    /// < Used for binding / unbinding
    pub handle: libc::c_ulong,
    /// < Type of memory to allocate
    pub type_: libc::c_ulong,
    /// < Physical used by i810
    pub physical: libc::c_ulong,
}
/// DRM_IOCTL_AGP_BIND and DRM_IOCTL_AGP_UNBIND ioctls argument type.
///
/// \sa drmAgpBind() and drmAgpUnbind().
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_agp_binding {
    /// < From drm_agp_buffer
    pub handle: libc::c_ulong,
    /// < In bytes -- will round to page boundary
    pub offset: libc::c_ulong,
}
/// DRM_IOCTL_AGP_INFO ioctl argument type.
///
/// \sa drmAgpVersionMajor(), drmAgpVersionMinor(), drmAgpGetMode(),
/// drmAgpBase(), drmAgpSize(), drmAgpMemoryUsed(), drmAgpMemoryAvail(),
/// drmAgpVendorId() and drmAgpDeviceId().
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_agp_info {
    pub agp_version_major: libc::c_int,
    pub agp_version_minor: libc::c_int,
    pub mode: libc::c_ulong,
    pub aperture_base: libc::c_ulong,
    pub aperture_size: libc::c_ulong,
    pub memory_allowed: libc::c_ulong,
    pub memory_used: libc::c_ulong,
    pub id_vendor: libc::c_ushort,
    pub id_device: libc::c_ushort,
}
/// DRM_IOCTL_SG_ALLOC ioctl argument type.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_scatter_gather {
    /// < In bytes -- will round to page boundary
    pub size: libc::c_ulong,
    /// < Used for mapping / unmapping
    pub handle: libc::c_ulong,
}
/// DRM_IOCTL_SET_VERSION ioctl argument type.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_set_version {
    pub drm_di_major: libc::c_int,
    pub drm_di_minor: libc::c_int,
    pub drm_dd_major: libc::c_int,
    pub drm_dd_minor: libc::c_int,
}
/// DRM_IOCTL_GEM_CLOSE ioctl argument type
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_gem_close {
    /// Handle of the object to be closed.
    pub handle: __u32,
    pub pad: __u32,
}
/// DRM_IOCTL_GEM_FLINK ioctl argument type
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_gem_flink {
    /// Handle for the object being named
    pub handle: __u32,
    /// Returned global name
    pub name: __u32,
}
/// DRM_IOCTL_GEM_OPEN ioctl argument type
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_gem_open {
    /// Name of object being opened
    pub name: __u32,
    /// Returned handle for the object
    pub handle: __u32,
    /// Returned size of the object
    pub size: __u64,
}
/// DRM_IOCTL_GET_CAP ioctl argument type
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_get_cap {
    pub capability: __u64,
    pub value: __u64,
}
/// DRM_IOCTL_SET_CLIENT_CAP ioctl argument type
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_set_client_cap {
    pub capability: __u64,
    pub value: __u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_prime_handle {
    pub handle: __u32,
    /// Flags.. only applicable for handle->fd
    pub flags: __u32,
    /// Returned dmabuf file descriptor
    pub fd: __s32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_syncobj_create {
    pub handle: __u32,
    pub flags: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_syncobj_destroy {
    pub handle: __u32,
    pub pad: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_syncobj_handle {
    pub handle: __u32,
    pub flags: __u32,
    pub fd: __s32,
    pub pad: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_syncobj_wait {
    pub handles: __u64,
    pub timeout_nsec: __s64,
    pub count_handles: __u32,
    pub flags: __u32,
    pub first_signaled: __u32,
    pub pad: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_syncobj_array {
    pub handles: __u64,
    pub count_handles: __u32,
    pub pad: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_crtc_get_sequence {
    pub crtc_id: __u32,
    pub active: __u32,
    pub sequence: __u64,
    pub sequence_ns: __s64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_crtc_queue_sequence {
    pub crtc_id: __u32,
    pub flags: __u32,
    pub sequence: __u64,
    pub user_data: __u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_mode_modeinfo {
    pub clock: __u32,
    pub hdisplay: __u16,
    pub hsync_start: __u16,
    pub hsync_end: __u16,
    pub htotal: __u16,
    pub hskew: __u16,
    pub vdisplay: __u16,
    pub vsync_start: __u16,
    pub vsync_end: __u16,
    pub vtotal: __u16,
    pub vscan: __u16,
    pub vrefresh: __u32,
    pub flags: __u32,
    pub type_: __u32,
    pub name: [libc::c_char; 32usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_mode_card_res {
    pub fb_id_ptr: __u64,
    pub crtc_id_ptr: __u64,
    pub connector_id_ptr: __u64,
    pub encoder_id_ptr: __u64,
    pub count_fbs: __u32,
    pub count_crtcs: __u32,
    pub count_connectors: __u32,
    pub count_encoders: __u32,
    pub min_width: __u32,
    pub max_width: __u32,
    pub min_height: __u32,
    pub max_height: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_mode_crtc {
    pub set_connectors_ptr: __u64,
    pub count_connectors: __u32,
    /// < Id
    pub crtc_id: __u32,
    /// < Id of framebuffer
    pub fb_id: __u32,
    /// < x Position on the framebuffer
    pub x: __u32,
    /// < y Position on the framebuffer
    pub y: __u32,
    pub gamma_size: __u32,
    pub mode_valid: __u32,
    pub mode: drm_mode_modeinfo,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_mode_set_plane {
    pub plane_id: __u32,
    pub crtc_id: __u32,
    pub fb_id: __u32,
    pub flags: __u32,
    pub crtc_x: __s32,
    pub crtc_y: __s32,
    pub crtc_w: __u32,
    pub crtc_h: __u32,
    pub src_x: __u32,
    pub src_y: __u32,
    pub src_h: __u32,
    pub src_w: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_mode_get_plane {
    pub plane_id: __u32,
    pub crtc_id: __u32,
    pub fb_id: __u32,
    pub possible_crtcs: __u32,
    pub gamma_size: __u32,
    pub count_format_types: __u32,
    pub format_type_ptr: __u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_mode_get_plane_res {
    pub plane_id_ptr: __u64,
    pub count_planes: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_mode_get_encoder {
    pub encoder_id: __u32,
    pub encoder_type: __u32,
    /// < Id of crtc
    pub crtc_id: __u32,
    pub possible_crtcs: __u32,
    pub possible_clones: __u32,
}
pub mod drm_mode_subconnector {
    pub type Type = u32;
    pub const DRM_MODE_SUBCONNECTOR_Automatic: Type = 0;
    pub const DRM_MODE_SUBCONNECTOR_Unknown: Type = 0;
    pub const DRM_MODE_SUBCONNECTOR_DVID: Type = 3;
    pub const DRM_MODE_SUBCONNECTOR_DVIA: Type = 4;
    pub const DRM_MODE_SUBCONNECTOR_Composite: Type = 5;
    pub const DRM_MODE_SUBCONNECTOR_SVIDEO: Type = 6;
    pub const DRM_MODE_SUBCONNECTOR_Component: Type = 8;
    pub const DRM_MODE_SUBCONNECTOR_SCART: Type = 9;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_mode_get_connector {
    pub encoders_ptr: __u64,
    pub modes_ptr: __u64,
    pub props_ptr: __u64,
    pub prop_values_ptr: __u64,
    pub count_modes: __u32,
    pub count_props: __u32,
    pub count_encoders: __u32,
    /// < Current Encoder
    pub encoder_id: __u32,
    /// < Id
    pub connector_id: __u32,
    pub connector_type: __u32,
    pub connector_type_id: __u32,
    pub connection: __u32,
    /// < width in millimeters
    pub mm_width: __u32,
    /// < height in millimeters
    pub mm_height: __u32,
    pub subpixel: __u32,
    pub pad: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_mode_property_enum {
    pub value: __u64,
    pub name: [libc::c_char; 32usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_mode_get_property {
    pub values_ptr: __u64,
    pub enum_blob_ptr: __u64,
    pub prop_id: __u32,
    pub flags: __u32,
    pub name: [libc::c_char; 32usize],
    pub count_values: __u32,
    pub count_enum_blobs: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_mode_connector_set_property {
    pub value: __u64,
    pub prop_id: __u32,
    pub connector_id: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_mode_obj_get_properties {
    pub props_ptr: __u64,
    pub prop_values_ptr: __u64,
    pub count_props: __u32,
    pub obj_id: __u32,
    pub obj_type: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_mode_obj_set_property {
    pub value: __u64,
    pub prop_id: __u32,
    pub obj_id: __u32,
    pub obj_type: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_mode_get_blob {
    pub blob_id: __u32,
    pub length: __u32,
    pub data: __u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_mode_fb_cmd {
    pub fb_id: __u32,
    pub width: __u32,
    pub height: __u32,
    pub pitch: __u32,
    pub bpp: __u32,
    pub depth: __u32,
    pub handle: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_mode_fb_cmd2 {
    pub fb_id: __u32,
    pub width: __u32,
    pub height: __u32,
    pub pixel_format: __u32,
    pub flags: __u32,
    pub handles: [__u32; 4usize],
    pub pitches: [__u32; 4usize],
    pub offsets: [__u32; 4usize],
    pub modifier: [__u64; 4usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_mode_fb_dirty_cmd {
    pub fb_id: __u32,
    pub flags: __u32,
    pub color: __u32,
    pub num_clips: __u32,
    pub clips_ptr: __u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_mode_mode_cmd {
    pub connector_id: __u32,
    pub mode: drm_mode_modeinfo,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_mode_cursor {
    pub flags: __u32,
    pub crtc_id: __u32,
    pub x: __s32,
    pub y: __s32,
    pub width: __u32,
    pub height: __u32,
    pub handle: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_mode_cursor2 {
    pub flags: __u32,
    pub crtc_id: __u32,
    pub x: __s32,
    pub y: __s32,
    pub width: __u32,
    pub height: __u32,
    pub handle: __u32,
    pub hot_x: __s32,
    pub hot_y: __s32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_mode_crtc_lut {
    pub crtc_id: __u32,
    pub gamma_size: __u32,
    pub red: __u64,
    pub green: __u64,
    pub blue: __u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_color_ctm {
    pub matrix: [__s64; 9usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_color_lut {
    pub red: __u16,
    pub green: __u16,
    pub blue: __u16,
    pub reserved: __u16,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_mode_crtc_page_flip {
    pub crtc_id: __u32,
    pub fb_id: __u32,
    pub flags: __u32,
    pub reserved: __u32,
    pub user_data: __u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_mode_crtc_page_flip_target {
    pub crtc_id: __u32,
    pub fb_id: __u32,
    pub flags: __u32,
    pub sequence: __u32,
    pub user_data: __u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_mode_create_dumb {
    pub height: __u32,
    pub width: __u32,
    pub bpp: __u32,
    pub flags: __u32,
    pub handle: __u32,
    pub pitch: __u32,
    pub size: __u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_mode_map_dumb {
    /// Handle for the object being mapped.
    pub handle: __u32,
    pub pad: __u32,
    /// Fake offset to use for subsequent mmap call
    ///
    /// This is a fixed-size type for 32/64 compatibility.
    pub offset: __u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_mode_destroy_dumb {
    pub handle: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_mode_atomic {
    pub flags: __u32,
    pub count_objs: __u32,
    pub objs_ptr: __u64,
    pub count_props_ptr: __u64,
    pub props_ptr: __u64,
    pub prop_values_ptr: __u64,
    pub reserved: __u64,
    pub user_data: __u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_format_modifier_blob {
    pub version: __u32,
    pub flags: __u32,
    pub count_formats: __u32,
    pub formats_offset: __u32,
    pub count_modifiers: __u32,
    pub modifiers_offset: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_format_modifier {
    pub formats: __u64,
    pub offset: __u32,
    pub pad: __u32,
    pub modifier: __u64,
}
/// Create a new 'blob' data property, copying length bytes from data pointer,
/// and returning new blob ID.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_mode_create_blob {
    /// Pointer to data to copy.
    pub data: __u64,
    /// Length of data to copy.
    pub length: __u32,
    /// Return: new property ID.
    pub blob_id: __u32,
}
/// Destroy a user-created blob property.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_mode_destroy_blob {
    pub blob_id: __u32,
}
/// Lease mode resources, creating another drm_master.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_mode_create_lease {
    /// Pointer to array of object ids (__u32)
    pub object_ids: __u64,
    /// Number of object ids
    pub object_count: __u32,
    /// flags for new FD (O_CLOEXEC, etc)
    pub flags: __u32,
    /// Return: unique identifier for lessee.
    pub lessee_id: __u32,
    /// Return: file descriptor to new drm_master file
    pub fd: __u32,
}
/// List lesses from a drm_master
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_mode_list_lessees {
    /// Number of lessees.
    /// On input, provides length of the array.
    /// On output, provides total number. No
    /// more than the input number will be written
    /// back, so two calls can be used to get
    /// the size and then the data.
    pub count_lessees: __u32,
    pub pad: __u32,
    /// Pointer to lessees.
    /// pointer to __u64 array of lessee ids
    pub lessees_ptr: __u64,
}
/// Get leased objects
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_mode_get_lease {
    /// Number of leased objects.
    /// On input, provides length of the array.
    /// On output, provides total number. No
    /// more than the input number will be written
    /// back, so two calls can be used to get
    /// the size and then the data.
    pub count_objects: __u32,
    pub pad: __u32,
    /// Pointer to objects.
    /// pointer to __u32 array of object ids
    pub objects_ptr: __u64,
}
/// Revoke lease
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_mode_revoke_lease {
    /// Unique ID of lessee
    pub lessee_id: __u32,
}
/// Header for events written back to userspace on the drm fd.  The
/// type defines the type of event, the length specifies the total
/// length of the event (including the header), and user_data is
/// typically a 64 bit value passed with the ioctl that triggered the
/// event.  A read on the drm fd will always only return complete
/// events, that is, if for example the read buffer is 100 bytes, and
/// there are two 64 byte events pending, only one will be returned.
///
/// Event types 0 - 0x7fffffff are generic drm events, 0x80000000 and
/// up are chipset specific.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_event {
    pub type_: __u32,
    pub length: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_event_vblank {
    pub base: drm_event,
    pub user_data: __u64,
    pub tv_sec: __u32,
    pub tv_usec: __u32,
    pub sequence: __u32,
    pub crtc_id: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct drm_event_crtc_sequence {
    pub base: drm_event,
    pub user_data: __u64,
    pub time_ns: __s64,
    pub sequence: __u64,
}
pub type drm_clip_rect_t = drm_clip_rect;
pub type drm_drawable_info_t = drm_drawable_info;
pub type drm_tex_region_t = drm_tex_region;
pub type drm_hw_lock_t = drm_hw_lock;
pub type drm_version_t = drm_version;
pub type drm_unique_t = drm_unique;
pub type drm_list_t = drm_list;
pub type drm_block_t = drm_block;
pub type drm_control_t = drm_control;
pub use self::drm_map_type::Type as drm_map_type_t;
pub use self::drm_map_flags as drm_map_flags_t;
pub type drm_ctx_priv_map_t = drm_ctx_priv_map;
pub type drm_map_t = drm_map;
pub type drm_client_t = drm_client;
pub use self::drm_stat_type::Type as drm_stat_type_t;
pub type drm_stats_t = drm_stats;
pub use self::drm_lock_flags as drm_lock_flags_t;
pub type drm_lock_t = drm_lock;
pub use self::drm_dma_flags as drm_dma_flags_t;
pub type drm_buf_desc_t = drm_buf_desc;
pub type drm_buf_info_t = drm_buf_info;
pub type drm_buf_free_t = drm_buf_free;
pub type drm_buf_pub_t = drm_buf_pub;
pub type drm_buf_map_t = drm_buf_map;
pub type drm_dma_t = drm_dma;
pub type drm_wait_vblank_t = drm_wait_vblank;
pub type drm_agp_mode_t = drm_agp_mode;
pub use self::drm_ctx_flags as drm_ctx_flags_t;
pub type drm_ctx_t = drm_ctx;
pub type drm_ctx_res_t = drm_ctx_res;
pub type drm_draw_t = drm_draw;
pub type drm_update_draw_t = drm_update_draw;
pub type drm_auth_t = drm_auth;
pub type drm_irq_busid_t = drm_irq_busid;
pub use self::drm_vblank_seq_type as drm_vblank_seq_type_t;
pub type drm_agp_buffer_t = drm_agp_buffer;
pub type drm_agp_binding_t = drm_agp_binding;
pub type drm_agp_info_t = drm_agp_info;
pub type drm_scatter_gather_t = drm_scatter_gather;
pub type drm_set_version_t = drm_set_version;
pub const DRM_MODE_PROP_SIGNED_RANGE: libc::c_uint = 128;
pub const DRM_MODE_PROP_OBJECT: libc::c_uint = 64;
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_VERSION"]
    pub static mut DRM_IOCTL_VERSION: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_GET_UNIQUE"]
    pub static mut DRM_IOCTL_GET_UNIQUE: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_GET_MAGIC"]
    pub static mut DRM_IOCTL_GET_MAGIC: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_IRQ_BUSID"]
    pub static mut DRM_IOCTL_IRQ_BUSID: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_GET_MAP"]
    pub static mut DRM_IOCTL_GET_MAP: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_GET_CLIENT"]
    pub static mut DRM_IOCTL_GET_CLIENT: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_GET_STATS"]
    pub static mut DRM_IOCTL_GET_STATS: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_SET_VERSION"]
    pub static mut DRM_IOCTL_SET_VERSION: libc::c_uint;
}
pub const DRM_IOCTL_MODESET_CTL: libc::c_uint = 1074291720;
pub const DRM_IOCTL_GEM_CLOSE: libc::c_uint = 1074291721;
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_GEM_FLINK"]
    pub static mut DRM_IOCTL_GEM_FLINK: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_GEM_OPEN"]
    pub static mut DRM_IOCTL_GEM_OPEN: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_GET_CAP"]
    pub static mut DRM_IOCTL_GET_CAP: libc::c_uint;
}
pub const DRM_IOCTL_SET_CLIENT_CAP: libc::c_uint = 1074816013;
pub const DRM_IOCTL_SET_UNIQUE: libc::c_uint = 1074816016;
pub const DRM_IOCTL_AUTH_MAGIC: libc::c_uint = 1074029585;
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_BLOCK"]
    pub static mut DRM_IOCTL_BLOCK: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_UNBLOCK"]
    pub static mut DRM_IOCTL_UNBLOCK: libc::c_uint;
}
pub const DRM_IOCTL_CONTROL: libc::c_uint = 1074291732;
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_ADD_MAP"]
    pub static mut DRM_IOCTL_ADD_MAP: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_ADD_BUFS"]
    pub static mut DRM_IOCTL_ADD_BUFS: libc::c_uint;
}
pub const DRM_IOCTL_MARK_BUFS: libc::c_uint = 1075864599;
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_INFO_BUFS"]
    pub static mut DRM_IOCTL_INFO_BUFS: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_MAP_BUFS"]
    pub static mut DRM_IOCTL_MAP_BUFS: libc::c_uint;
}
pub const DRM_IOCTL_FREE_BUFS: libc::c_uint = 1074816026;
pub const DRM_IOCTL_RM_MAP: libc::c_uint = 1076388891;
pub const DRM_IOCTL_SET_SAREA_CTX: libc::c_uint = 1074816028;
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_GET_SAREA_CTX"]
    pub static mut DRM_IOCTL_GET_SAREA_CTX: libc::c_uint;
}
pub const DRM_IOCTL_SET_MASTER: libc::c_uint = 25630;
pub const DRM_IOCTL_DROP_MASTER: libc::c_uint = 25631;
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_ADD_CTX"]
    pub static mut DRM_IOCTL_ADD_CTX: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_RM_CTX"]
    pub static mut DRM_IOCTL_RM_CTX: libc::c_uint;
}
pub const DRM_IOCTL_MOD_CTX: libc::c_uint = 1074291746;
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_GET_CTX"]
    pub static mut DRM_IOCTL_GET_CTX: libc::c_uint;
}
pub const DRM_IOCTL_SWITCH_CTX: libc::c_uint = 1074291748;
pub const DRM_IOCTL_NEW_CTX: libc::c_uint = 1074291749;
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_RES_CTX"]
    pub static mut DRM_IOCTL_RES_CTX: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_ADD_DRAW"]
    pub static mut DRM_IOCTL_ADD_DRAW: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_RM_DRAW"]
    pub static mut DRM_IOCTL_RM_DRAW: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_DMA"]
    pub static mut DRM_IOCTL_DMA: libc::c_uint;
}
pub const DRM_IOCTL_LOCK: libc::c_uint = 1074291754;
pub const DRM_IOCTL_UNLOCK: libc::c_uint = 1074291755;
pub const DRM_IOCTL_FINISH: libc::c_uint = 1074291756;
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_PRIME_HANDLE_TO_FD"]
    pub static mut DRM_IOCTL_PRIME_HANDLE_TO_FD: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_PRIME_FD_TO_HANDLE"]
    pub static mut DRM_IOCTL_PRIME_FD_TO_HANDLE: libc::c_uint;
}
pub const DRM_IOCTL_AGP_ACQUIRE: libc::c_uint = 25648;
pub const DRM_IOCTL_AGP_RELEASE: libc::c_uint = 25649;
pub const DRM_IOCTL_AGP_ENABLE: libc::c_uint = 1074291762;
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_AGP_INFO"]
    pub static mut DRM_IOCTL_AGP_INFO: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_AGP_ALLOC"]
    pub static mut DRM_IOCTL_AGP_ALLOC: libc::c_uint;
}
pub const DRM_IOCTL_AGP_FREE: libc::c_uint = 1075864629;
pub const DRM_IOCTL_AGP_BIND: libc::c_uint = 1074816054;
pub const DRM_IOCTL_AGP_UNBIND: libc::c_uint = 1074816055;
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_SG_ALLOC"]
    pub static mut DRM_IOCTL_SG_ALLOC: libc::c_uint;
}
pub const DRM_IOCTL_SG_FREE: libc::c_uint = 1074816057;
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_WAIT_VBLANK"]
    pub static mut DRM_IOCTL_WAIT_VBLANK: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_CRTC_GET_SEQUENCE"]
    pub static mut DRM_IOCTL_CRTC_GET_SEQUENCE: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_CRTC_QUEUE_SEQUENCE"]
    pub static mut DRM_IOCTL_CRTC_QUEUE_SEQUENCE: libc::c_uint;
}
pub const DRM_IOCTL_UPDATE_DRAW: libc::c_uint = 1075340351;
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_MODE_GETRESOURCES"]
    pub static mut DRM_IOCTL_MODE_GETRESOURCES: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_MODE_GETCRTC"]
    pub static mut DRM_IOCTL_MODE_GETCRTC: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_MODE_SETCRTC"]
    pub static mut DRM_IOCTL_MODE_SETCRTC: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_MODE_CURSOR"]
    pub static mut DRM_IOCTL_MODE_CURSOR: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_MODE_GETGAMMA"]
    pub static mut DRM_IOCTL_MODE_GETGAMMA: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_MODE_SETGAMMA"]
    pub static mut DRM_IOCTL_MODE_SETGAMMA: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_MODE_GETENCODER"]
    pub static mut DRM_IOCTL_MODE_GETENCODER: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_MODE_GETCONNECTOR"]
    pub static mut DRM_IOCTL_MODE_GETCONNECTOR: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_MODE_ATTACHMODE"]
    pub static mut DRM_IOCTL_MODE_ATTACHMODE: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_MODE_DETACHMODE"]
    pub static mut DRM_IOCTL_MODE_DETACHMODE: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_MODE_GETPROPERTY"]
    pub static mut DRM_IOCTL_MODE_GETPROPERTY: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_MODE_SETPROPERTY"]
    pub static mut DRM_IOCTL_MODE_SETPROPERTY: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_MODE_GETPROPBLOB"]
    pub static mut DRM_IOCTL_MODE_GETPROPBLOB: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_MODE_GETFB"]
    pub static mut DRM_IOCTL_MODE_GETFB: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_MODE_ADDFB"]
    pub static mut DRM_IOCTL_MODE_ADDFB: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_MODE_RMFB"]
    pub static mut DRM_IOCTL_MODE_RMFB: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_MODE_PAGE_FLIP"]
    pub static mut DRM_IOCTL_MODE_PAGE_FLIP: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_MODE_DIRTYFB"]
    pub static mut DRM_IOCTL_MODE_DIRTYFB: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_MODE_CREATE_DUMB"]
    pub static mut DRM_IOCTL_MODE_CREATE_DUMB: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_MODE_MAP_DUMB"]
    pub static mut DRM_IOCTL_MODE_MAP_DUMB: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_MODE_DESTROY_DUMB"]
    pub static mut DRM_IOCTL_MODE_DESTROY_DUMB: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_MODE_GETPLANERESOURCES"]
    pub static mut DRM_IOCTL_MODE_GETPLANERESOURCES: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_MODE_GETPLANE"]
    pub static mut DRM_IOCTL_MODE_GETPLANE: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_MODE_SETPLANE"]
    pub static mut DRM_IOCTL_MODE_SETPLANE: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_MODE_ADDFB2"]
    pub static mut DRM_IOCTL_MODE_ADDFB2: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_MODE_OBJ_GETPROPERTIES"]
    pub static mut DRM_IOCTL_MODE_OBJ_GETPROPERTIES: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_MODE_OBJ_SETPROPERTY"]
    pub static mut DRM_IOCTL_MODE_OBJ_SETPROPERTY: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_MODE_CURSOR2"]
    pub static mut DRM_IOCTL_MODE_CURSOR2: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_MODE_ATOMIC"]
    pub static mut DRM_IOCTL_MODE_ATOMIC: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_MODE_CREATEPROPBLOB"]
    pub static mut DRM_IOCTL_MODE_CREATEPROPBLOB: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_MODE_DESTROYPROPBLOB"]
    pub static mut DRM_IOCTL_MODE_DESTROYPROPBLOB: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_SYNCOBJ_CREATE"]
    pub static mut DRM_IOCTL_SYNCOBJ_CREATE: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_SYNCOBJ_DESTROY"]
    pub static mut DRM_IOCTL_SYNCOBJ_DESTROY: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_SYNCOBJ_HANDLE_TO_FD"]
    pub static mut DRM_IOCTL_SYNCOBJ_HANDLE_TO_FD: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_SYNCOBJ_FD_TO_HANDLE"]
    pub static mut DRM_IOCTL_SYNCOBJ_FD_TO_HANDLE: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_SYNCOBJ_WAIT"]
    pub static mut DRM_IOCTL_SYNCOBJ_WAIT: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_SYNCOBJ_RESET"]
    pub static mut DRM_IOCTL_SYNCOBJ_RESET: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_SYNCOBJ_SIGNAL"]
    pub static mut DRM_IOCTL_SYNCOBJ_SIGNAL: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_MODE_CREATE_LEASE"]
    pub static mut DRM_IOCTL_MODE_CREATE_LEASE: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_MODE_LIST_LESSEES"]
    pub static mut DRM_IOCTL_MODE_LIST_LESSEES: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_MODE_GET_LEASE"]
    pub static mut DRM_IOCTL_MODE_GET_LEASE: libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}DRM_IOCTL_MODE_REVOKE_LEASE"]
    pub static mut DRM_IOCTL_MODE_REVOKE_LEASE: libc::c_uint;
}
